#!/usr/bin/env bash

# safety subshell to avoid executing anything in case this script is not downloaded properly
(

    ##########################
    #--[ Global Variables ]--#
    ##########################

    # @VARIABLE: VERSION
    # @DESCRIPTION:
    # Version of this script.
    VERSION=0.2.0

    # Default base URL for short package names
    BASE_URL=${EPM_REPO_BASE:-"https://github.com/e-wrks"}

    # @VARIABLE: SCRIPT
    # @DESCRIPTION:
    # Name of this script. This will be the
    # shell name if this script is sourced, so
    # only rely on this for echos and trivial things.
    SCRIPT="$(basename "$0")"

    # the nearest home directory for local packages
    EPM_HOME="Yet-Discovered"
    # all effective epm home's bin directory separated by colon (:)
    EPM_PATH=""

    init_epm_home() {
        (
            [ -w "${EPM_HOME}/edh_modules" ] || edo mkdir "${EPM_HOME}/edh_modules"
            [ -w "${EPM_HOME}/edh-universe/bin" ] || edo mkdir -p "${EPM_HOME}/edh-universe/bin"
        ) || die "Can NOT create EPM home artifacts in [${EPM_HOME}]"
    }

    locate_epm_home() {

        locate_home_at() { (
            parent_dir=$(dirname "$1")
            if [ "${parent_dir}" == "$1" ]; then
                ppath=""
            else
                ppath=$(locate_home_at "${parent_dir}")
            fi
            if [ -x "$1"/edh-universe/bin ]; then
                if [ -n "${ppath}" ]; then
                    echo "$1"/edh-universe/bin:"${ppath}"
                else
                    echo "$1"/edh-universe/bin
                fi
            else
                echo "${ppath}"
            fi

        ); }

        EPM_PATH=$(locate_home_at "$(pwd)")
        EPM_HOME="${EPM_PATH%%/edh-universe/bin*}"

        if [ -e "${EPM_HOME}" ]; then
            if [ ! -d "${EPM_HOME}" ]; then
                die "Not a directory: ${EPM_HOME}"
            elif [ -w "${EPM_HOME}" ]; then
                status_message " >> Managing packages at EPM home [${EPM_HOME}] <<"
            elif ${MODIFYING_EPM_HOME}; then
                red_message " >> Readonly EPM home at [${EPM_HOME}] <<"
                return 1
            fi
        elif ${CREATING_EPM_HOME}; then
            EPM_HOME=$(pwd)
            warning_message "Creating new EPM home at [${EPM_HOME}] ..."
            init_epm_home
            if [ -n "${EPM_PATH}" ]; then
                EPM_PATH="${EPM_HOME}/edh-universe/bin:${EPM_PATH}"
            else
                EPM_PATH="${EPM_HOME}/edh-universe/bin"
            fi
        else
            warning_message "No effective EPM home for directory [$(pwd)]"
            return 1
        fi

        export EPM_PATH EPM_HOME
    }

    add_cabal_packages() { (
        cd "${EPM_HOME}/edh-universe" || die "Bad EPM home [${EPM_HOME}]"
        find . -name \*.cabal |
            fgrep -v '/dist-newstyle/' | fgrep -v '/.stack-work/' |
            while read -r fn; do
                shadowed=0
                for dhome in "${DESCENDANT_HOMES}"; do
                    [ -e "${dhome}"/edh-universe/"${fn#./}" ] && shadowed=1
                done
                if [ "${shadowed}" == "0" ]; then
                    pkg_dir="$(dirname "${fn}")"
                    echo "  ${EPM_HOME}/edh-universe/${pkg_dir#./}"
                fi
            done
    ); }

    add_stack_packages() { (
        cd "${EPM_HOME}/edh-universe" || die "Bad EPM home [${EPM_HOME}]"
        find . -name \*.cabal |
            fgrep -v '/dist-newstyle/' | fgrep -v '/.stack-work/' |
            while read -r fn; do
                shadowed=0
                for dhome in "${DESCENDANT_HOMES}"; do
                    [ -e "${dhome}"/edh-universe/"${fn#./}" ] && shadowed=1
                done
                if [ "${shadowed}" == "0" ]; then
                    pkg_dir="$(dirname "${fn}")"
                    echo " - ${EPM_HOME}/edh-universe/${pkg_dir#./}"
                fi
            done
    ); }

    update_project_packages() {
        cd "${EPM_HOME}/edh-universe" || die "Bad EPM home [${EPM_HOME}]"

        (
            if [ -f "cabal.project" ]; then
                while IFS= read -r line; do
                    [ "${line}" == '-- FOLLOWING CONTENTS GONNA BE OVERWRITTEN BY EPM --' ] && break
                    echo "$line"
                done <"cabal.project"
            else
                echo ''
                echo "-- Please change Cabal project settings per your needs"
                echo ''
            fi
            echo '-- FOLLOWING CONTENTS GONNA BE OVERWRITTEN BY EPM --'
            echo ''
            echo 'packages:'

            export DESCENDANT_HOMES=''
            add_cabal_packages
            export DESCENDANT_HOMES="${EPM_HOME}"
            process_parent_homes_from() { (
                parent_dir=$(dirname "$1")
                if [ "${parent_dir}" == "$1" ]; then
                    return 0
                fi
                if [ -x "${parent_dir}"/edh-universe/bin ]; then
                    EPM_HOME="${parent_dir}" add_cabal_packages
                    export DESCENDANT_HOMES="${DESCENDANT_HOMES} ${parent_dir}"
                fi
                process_parent_homes_from "${parent_dir}"
            ); }
            process_parent_homes_from "${EPM_HOME}"
        ) >"_new_cabal.project"
        edo mv -f "_new_cabal.project" "cabal.project"

        (
            if [ -f "stack.yaml" ]; then
                while IFS= read -r line; do
                    [ "${line}" == '## FOLLOWING CONTENTS GONNA BE OVERWRITTEN BY EPM ##' ] && break
                    echo "$line"
                done <"stack.yaml"
            else
                echo ''
                echo "# Please change the resolver and other Stack settings per your needs"
                echo 'resolver: lts-16.11'
                echo ''
            fi
            echo '## FOLLOWING CONTENTS GONNA BE OVERWRITTEN BY EPM ##'
            echo ''
            echo "local-bin-path: ${EPM_HOME}/edh-universe/bin"
            echo 'packages:'

            export DESCENDANT_HOMES=''
            add_stack_packages
            export DESCENDANT_HOMES="${EPM_HOME}"
            process_parent_homes_from() { (
                parent_dir=$(dirname "$1")
                if [ "${parent_dir}" == "$1" ]; then
                    return 0
                fi
                if [ -x "${parent_dir}"/edh-universe/bin ]; then
                    EPM_HOME="${parent_dir}" add_stack_packages
                    export DESCENDANT_HOMES="${DESCENDANT_HOMES} ${parent_dir}"
                fi
                process_parent_homes_from "${parent_dir}"
            ); }
            process_parent_homes_from "${EPM_HOME}"
        ) >"_new_stack.yaml"
        edo mv -f "_new_stack.yaml" "stack.yaml"
    }

    # whether we tend to create an EPM home
    CREATING_EPM_HOME=false
    # whether we tend to modify an EPM home
    MODIFYING_EPM_HOME=false
    # whether build Haskell source by EPM
    EPM_BUILD_HS=false

    # @VARIABLE: VERBOSE
    # @DESCRIPTION:
    # Whether to print verbose messages in this script.
    VERBOSE=false

    # @VARIABLE: FORCE
    # @DESCRIPTION:
    # Whether to force installation and overwrite files.
    FORCE=false

    # options in listing subcommand
    SHOW_REPO=false
    SHOW_BRANCH=false
    SHOW_MODULES=false

    ####################
    #--[ Print Help ]--#
    ####################

    # @FUNCTION: usage
    # @DESCRIPTION:
    # Print the help message for 'epm' to STDERR
    # and exit the script with status code 1.
    usage() {
        (echo >&2 "epm ${VERSION} >> Edh Package Manager <<

USAGE:
    ${SCRIPT} [FLAGS] <SUBCOMMAND>

FLAGS:
    -v, --verbose      Enable verbose output
    -h, --help         Prints help information
    -V, --version      Prints version information
    -B, --base <URL>   URL prefix for upstream package repositories
                         default:  ${BASE_URL}
                         environment variable EPM_REPO_BASE overrides above

SUBCOMMANDS:
    init               Initialize current working directory as an EPM home
    install     | i    Install new, or change branches of existing packages 
    list        | l    List homes and packages
    update | up | u    Pull upstream changes of packages from tracked branches
    with        | w    Run command within the directory of a package
    run | exec  | x    Run command with all effective EPM home's bin on \$PATH
    rm                 Remove specified package(s) from nearest EPM home
")
        exit 1
    }

    # @FUNCTION: init_usage
    # @DESCRIPTION:
    # Print the help message for 'epm init' to STDERR
    # and exit the script with status code 1.
    init_usage() {
        (echo >&2 "epm-init
Initialize current working directory as an EPM home, with packages as specified

USAGE:
    ${SCRIPT} init [FLAGS] [ -B <repo-base> ] [ -b <branch> ] [ <PKGn> | <URLn> ] ...

FLAGS:
    -h, --help            Prints help information

ARGS:
    -b <branch>           Branch to checkout and track
                only applies to the immediately following package
                default: master
    -B, --base <URL>      URL prefix for upstream package repositories
                    default:  ${BASE_URL}
                    environment variable EPM_REPO_BASE overrides above
    <PKGn>                E.g. nedh or sedh
    <URLn>                E.g. \"https://github.com/e-wrks/hasdb\"

EXAMPLES:
    epm init -b 0.3 edh -b 0.1 nedh \\
     -B https://git.corporate.lan -b golden esb/cord -b qa esb/mart
")
        exit 1
    }

    # @FUNCTION: install_usage
    # @DESCRIPTION:
    # Print the help message for 'epm install' to STDERR
    # and exit the script with status code 1.
    install_usage() {
        (echo >&2 "epm-install
Install packages as specified

USAGE:
    ${SCRIPT} install [FLAGS] [ -B <repo-base> ] [ -b <branch> ] [ <PKGn> | <URLn> ] ...

FLAGS:
    -h, --help            Prints help information

ARGS:
    -b <branch>           Branch to checkout and track
                only applies to the immediately following package
                default: master
    -B, --base <URL>      URL prefix for upstream package repositories
                    default:  ${BASE_URL}
                    environment variable EPM_REPO_BASE overrides above
    <PKGn>                E.g. nedh or sedh
    <URLn>                E.g. \"https://github.com/e-wrks/hasdb\"

EXAMPLES:
    epm install -b 0.3 edh -b 0.1 nedh \\
     -B https://git.corporate.lan -b golden esb/cord -b qa esb/mart
")
        exit 1
    }

    # @FUNCTION: with_usage
    # @DESCRIPTION:
    # Print the help message for 'epm with' to STDERR
    # and exit the script with status code 1.
    with_usage() {
        (echo >&2 "epm-with
Run command within the directory of a package

USAGE:
    ${SCRIPT} with [FLAGS] <PKG> [ <CMD> [ <ARGn> ... ] ]

FLAGS:
    -h, --help              Prints help information

ARGS:
    <PKG>                   E.g. \"nedh\" or \"sedh\"
    <CMD> [ <ARGn> ... ]    E.g. \"git reset --hard\" or \"git diff\"
                              default: bash
")
        exit 1
    }

    # @FUNCTION: epm_exec_usage
    # @DESCRIPTION:
    # Print the help message for 'epm run' to STDERR
    # and exit the script with status code 1.
    epm_exec_usage() {
        (echo >&2 "epm-run
Run command with all effective EPM home's bin on \$PATH

USAGE:
    ${SCRIPT} run [FLAGS] <CMD> [ <ARGn> ... ]

FLAGS:
    -h, --help              Prints help information

ARGS:
    <CMD> [ <ARGn> ... ]    E.g. \"edhi\" or \"cabal install all:exes\"
")
        exit 1
    }

    # @FUNCTION: rm_usage
    # @DESCRIPTION:
    # Print the help message for 'epm rm' to STDERR
    # and exit the script with status code 1.
    rm_usage() {
        (echo >&2 "epm-rm
Remove the specified packages installed by epm

USAGE:
    ${SCRIPT} rm [FLAGS] <PKG1> [ <PKG2> ... ]

FLAGS:
    -h, --help       Prints help information

ARGS:
    <PKGn>           E.g. \"nedh\" or \"sedh\"
")
        exit 1
    }

    # @FUNCTION: list_usage
    # @DESCRIPTION:
    # Print the help message for 'epm list' to STDERR
    # and exit the script with status code 1.
    list_usage() {
        (echo >&2 "epm-list
Show locally installed packages

USAGE:
    ${SCRIPT} list [FLAGS]

FLAGS:
    -h, --help             Prints help information
    -u, --upstream         Show repository URL
    -b, --branch           Show branches
    -m, --modules          List Edh modules
")
        exit 1
    }

    # @FUNCTION: update_usage
    # @DESCRIPTION:
    # Print the help message for 'epm update' to STDERR
    # and exit the script with status code 1.
    update_usage() {
        (echo >&2 "epm-update
Pull upstream changes of packages from tracked branches

USAGE:
    ${SCRIPT} update [FLAGS]

FLAGS:
    -h, --help             Prints help information
")
        exit 1
    }

    ############################
    #--[ Subcommand install ]--#
    ############################

    install_pkgs() { (
        cd "${EPM_HOME}"
        while [ $# -gt 0 ]; do
            case $1 in
            -B | --base)
                if [ $# -lt 2 ]; then
                    install_usage
                fi
                BASE_URL="$2"
                shift 2
                ;;
            -b)
                if [ $# -lt 2 ]; then
                    install_usage
                fi
                BRANCH="$2"
                shift 2
                ;;
            *)
                install_pkg "$1"
                # -b has to be specified per pkg
                unset BRANCH
                shift 1
                ;;
            esac
        done
        update_project_packages
    ); }

    # @FUNCTION: install_pkg
    # @USAGE: <PKG>
    # @DESCRIPTION:
    # Installs the specified package
    install_pkg() {
        if [ "${1#*://}" == "$1" ]; then
            full_url="${BASE_URL}/$1"
        else
            full_url="$1"
        fi
        pkg_id=${full_url#*://*/}
        pkg_dir=edh-universe/"${pkg_id}"

        status_message "Installing $1 to ${pkg_dir} ..."
        (
            if [ -d "${pkg_dir}" ]; then
                edo pushd "${pkg_dir}" >/dev/null
                edo git fetch --all
                edo git checkout -B "${BRANCH:-master}" -t origin/"${BRANCH:-master}"
                edo popd >/dev/null
            else
                edo git clone -b "${BRANCH:-master}" "${full_url}" "${pkg_dir}"
            fi
        ) || die "Failed cloning ${full_url} to ${pkg_dir}"

        (
            edo pushd edh_modules >/dev/null
            for a in ../"${pkg_dir}"/edh_modules/*; do
                b=$(basename "$a")
                edo rm -rf "./$b" 2>/dev/null
                edo ln -s "$a" "$b"
            done
            edo popd >/dev/null
        ) || die "Failed linking Edh module artifacts"

        ${EPM_BUILD_HS} && ( (
            edo pushd "${pkg_dir}" >/dev/null
            status_message "Building Haskell components for ${pkg_id} ..."
            edo cabal build all
            edo popd >/dev/null
        ) || red_message "Failed building Haskell components for ${pkg_id}")

        status_message "Installed $1 ."

        unset full_url pkg_id pkg_dir a b
    }

    #########################
    #--[ Subcommand list ]--#
    #########################

    # @FUNCTION: list
    # @USAGE: <tool> <raw-format> <criteria>
    # @DESCRIPTION:
    # List local packages installed by epm
    list_pkgs() { (
        IFS=: ps=(${EPM_PATH})
        for p in ${ps[@]}; do
            EPM_HOME=${p%%/edh-universe/bin}
            status_message "  > EPM home at [${EPM_HOME}] <"
            cd "${EPM_HOME}"
            find edh-universe -name edh_modules |
                fgrep -v '/dist-newstyle/' | fgrep -v '/.stack-work/' |
                while read -r pkg_dir1; do
                    pkg_dir="${pkg_dir1%/edh_modules}"
                    pkg_id="${pkg_dir#edh-universe/}"
                    (
                        edo pushd "${pkg_dir}" >/dev/null
                        echo "${pkg_id} - $(git describe --all --dirty --broken)"
                        if ${SHOW_REPO}; then
                            echo " - From: $(
                                git config remote.$(git config branch.$(git branch --format '%(refname:short)').remote).url
                            )"
                        fi
                        if ${SHOW_BRANCH}; then
                            echo " - Branch: $(edo git branch -vv)"
                        fi
                        if ${SHOW_MODULES}; then
                            echo " - Modules:"
                            find edh_modules -type f | while read -r modu; do
                                echo "    ${modu}"
                            done
                        fi
                        edo popd >/dev/null
                    ) || die "Failed browsing package ${pkg_id}"
                done
        done
    ); }

    #########################
    #--[ Subcommand with ]--#
    #########################

    # Run command in a package's directory
    with_pkg() { (
        pkg="$1"
        shift 1
        IFS=: ps=(${EPM_PATH})
        for p in ${ps[@]}; do
            EPM_HOME=${p%%/edh-universe/bin}
            cd "${EPM_HOME}"
            pkg_dir=$(
                find edh-universe -name edh_modules |
                    fgrep -v '/dist-newstyle/' | fgrep -v '/.stack-work/' |
                    while read -r pkg_dir1; do
                        pkg_dir="${pkg_dir1%/edh_modules}"
                        pkg_id="${pkg_dir#edh-universe/}"
                        [ "${pkg_id%/${pkg}}" != "${pkg_id}" ] && echo "${pkg_dir}"
                    done
            )
            if [ -d "${pkg_dir}" ]; then
                if [ "$1" == "cabal" -a "$2" == "install" ]; then
                    shift 2
                    # implant `--overwrite-policy=always --installdir=${EPM_HOME}/edh-universe/bin`
                    # to `cabal install` cmdl, magically !
                    set -- cabal install --overwrite-policy=always --installdir=${EPM_HOME}/edh-universe/bin "$@"
                elif [ $# -lt 1 ]; then
                    set -- bash
                fi

                pkg_id="${pkg_dir#edh-universe/}"
                status_message " >> With Edh package [${pkg_id}] in EPM home [${EPM_HOME}] <<"
                edo pushd "${pkg_dir}" >/dev/null
                export PATH="${EPM_PATH}":"${PATH}"
                exec $*
                edo popd >/dev/null
                red_message "You've been kicked back."
            fi
        done
        warning_message "No such package [${pkg}] in any effective EPM home"
    ); }

    #########################
    #--[ Subcommand run ]--#
    #########################

    # Run command with all effective EPM home's bin on $PATH
    epm_exec() {
        if [ "$1" == "cabal" -a "$2" == "install" ]; then
            shift 2
            # implant `--overwrite-policy=always --installdir=${EPM_HOME}/edh-universe/bin`
            # to `cabal install` cmdl, magically !
            set -- cabal install --overwrite-policy=always --installdir=${EPM_HOME}/edh-universe/bin "$@"
        fi

        collect_py_path() {
            if [ ! -x "$1/edh-universe" ]; then
                echo "${PYP}"
                return 1 # reached an inaccessible epm home, stop here
            fi
            PYP=$(find "$1/edh-universe" -type d -name host.py | (
                while read -r pyr; do
                    if [ -n "${PYP}" ]; then
                        PYP="${PYP}":"${pyr}"
                    else
                        PYP="${pyr}"
                    fi
                done
                echo "${PYP}"
            ))

            parent_dir=$(dirname "$1")
            if [ "${parent_dir}" == "$1" ]; then
                echo "${PYP}"
                return 0
            fi

            export PYP
            collect_py_path "${parent_dir}"
        }
        PYP=$(PYP="" collect_py_path "${EPM_HOME}")
        if [ -n "${PYP}" ]; then
            if [ -n "${PYTHONPATH}" ]; then
                export PYTHONPATH="${PYP}":"${PYTHONPATH}"
            else
                export PYTHONPATH="${PYP}"
            fi
        fi

        export PATH="${EPM_PATH}":"${PATH}"
        exec $*
        red_message "You've been kicked back."
    }

    #########################
    #--[ Subcommand update ]--#
    #########################

    # Update local packages installed by epm
    update_pkgs() { (
        cd "${EPM_HOME}"
        find edh-universe -name edh_modules |
            fgrep -v '/dist-newstyle/' | fgrep -v '/.stack-work/' |
            while read -r pkg_dir1; do
                pkg_dir="${pkg_dir1%/edh_modules}"
                pkg_id="${pkg_dir#edh-universe/}"

                status_message "Updating ${pkg_id}"

                (
                    edo pushd "${pkg_dir}" >/dev/null
                    edo git pull
                    edo popd >/dev/null
                ) || die "Failed updating package ${pkg_id}"

                (
                    find edh_modules -type l | while read -r modu_root; do
                        mr_path=$(readlink "${modu_root}")
                        if [ "${mr_path#../${pkg_dir1}/}" != "${mr_path}" ]; then
                            edo rm "${modu_root}" || die "Failed unlink ${modu_root}"
                        fi
                    done

                    edo pushd edh_modules >/dev/null
                    for a in ../"${pkg_dir}"/edh_modules/*; do
                        b=$(basename "$a")
                        edo rm -rf "./$b" 2>/dev/null
                        edo ln -s "$a" "$b"
                    done
                    edo popd >/dev/null
                ) || die "Failed re-linking Edh module artifacts"

                ${EPM_BUILD_HS} && ( (
                    edo pushd "${pkg_dir}" >/dev/null
                    status_message "Building Haskell components for ${pkg_id} ..."
                    edo cabal build all
                    edo popd >/dev/null
                ) || red_message "Failed building Haskell components for ${pkg_id}")
            done
    ); }

    #######################
    #--[ Subcommand rm ]--#
    #######################

    # @FUNCTION: rm_pkgs
    # @USAGE: <ghcversion>
    # @DESCRIPTION:
    # Removes the specified package(s) installed by epm.
    rm_pkgs() { (
        cd "${EPM_HOME}"
        find edh-universe -name edh_modules |
            fgrep -v '/dist-newstyle/' | fgrep -v '/.stack-work/' |
            while read -r pkg_dir1; do
                pkg_dir="${pkg_dir1%/edh_modules}"
                pkg_id="${pkg_dir#edh-universe/}"
                edo pushd "${pkg_dir}" >/dev/null
                pkg_repo="$(
                    git config remote.$(git config branch.$(git branch --format '%(refname:short)').remote).url
                )"
                edo popd >/dev/null
                for name2rm in "$@"; do
                    if [ "${pkg_id%/${name2rm}}" != "${pkg_id}" ]; then
                        warning_message "Package [${pkg_id}] has upstream ${pkg_repo}"
                        if ask_for_confirmation "Remove it from [${EPM_HOME}] ?"; then
                            status_message "Removing ${pkg_dir} ..."
                            find edh_modules -type l | while read -r modu_root; do
                                mr_path=$(readlink "${modu_root}")
                                if [ "${mr_path#../${pkg_dir1}/}" != "${mr_path}" ]; then
                                    edo rm "${modu_root}" || die "Failed unlink ${modu_root}"
                                fi
                            done
                            edo rm -rf "${pkg_dir}"
                        fi
                    fi
                done
            done
        update_project_packages
    ); }

    ###########################
    #--[ Utility functions ]--#
    ###########################

    # @FUNCTION: die
    # @USAGE: [msg]
    # @DESCRIPTION:
    # Exits the shell script with status code 2
    # and prints the given message in red to STDERR, if any.
    die() {
        (red_message >&2 "$1")
        exit 2
    }

    # @FUNCTION: edo
    # @USAGE: <command>
    # @DESCRIPTION:
    # Executes the given command. Also prints what
    # command that is (in blue) if verbosity is enabled.
    # Exits with status code 2 if the command failed.
    edo() {
        if ${VERBOSE}; then
            printf "\\033[0;34m%s\\033[0m\\n" "$*" 1>&2
        fi
        "$@" || exit 2
    }

    # @FUNCTION: debug_message
    # @USAGE: <msg>
    # @DESCRIPTION:
    # Print a blue debug message if verbosity is enabled.
    debug_message() {
        if ${VERBOSE}; then
            (printf >&2 "\\033[0;34m%s\\033[0m\\n" "$1")
        fi
    }

    # @FUNCTION: optionv
    # @USAGE: <arg1> [arg2]
    # @DESCRIPTION:
    # If verbosity is enabled, echo the first argument, otherwise
    # the second (if any).
    # @STDOUT: first or second argument
    optionv() {
        if ${VERBOSE}; then
            echo "$1"
        else
            if [ -n "$2" ]; then
                echo "$2"
            fi
        fi
    }

    # @FUNCTION: status_message
    # @USAGE: <msg>
    # @DESCRIPTION:
    # Print a green status message.
    status_message() {
        printf "\\033[0;32m%s\\033[0m\\n" "$1"
    }

    # @FUNCTION: warning_message
    # @USAGE: <msg>
    # @DESCRIPTION:
    # Print a yellow warning message.
    warning_message() {
        printf "\\033[1;33m%s\\033[0m\\n" "$1"
    }

    # @FUNCTION: red_message
    # @USAGE: <msg>
    # @DESCRIPTION:
    # Print a red message.
    red_message() {
        printf "\\033[0;31m%s\\033[0m\\n" "$1"
    }

    # @FUNCTION: command_exists
    # @USAGE: <command>
    # @DESCRIPTION:
    # Check if a command exists (no arguments).
    # @RETURNS: 0 if the command exists, non-zero otherwise
    command_exists() {
        [ -z "$1" ] && die "Internal error: no argument given to command_exists"

        command -V "$1" >/dev/null 2>&1
        return $?
    }

    # @FUNCTION: check_required_commands
    # @USAGE: [additional-commands]
    # @DESCRIPTION:
    # Check that all required commands for this script exist.
    # @STDOUT: The commands that do not exist
    # @RETURNS: 0 if all command exists, non-zero otherwise
    check_required_commands() {
        _missing_commands=

        for com in "$@" basename dirname find fgrep git; do
            command_exists "${com}" || {
                _missing_commands="${_missing_commands} ${com}"
            }
        done
        unset com

        if [ -n "${_missing_commands}" ]; then
            printf "%s" "${_missing_commands}"
            unset _missing_commands
            return 1
        else
            unset _missing_commands
            return 0
        fi
    }

    # @FUNCTION: ask_for_confirmation
    # @USAGE: [confirmation-msg]
    # @DESCRIPTION:
    # Asks the user for confirmation and returns 0 for yes, 1 for no.
    # @RETURN: 0 if user confirmed, 1 otherwise
    ask_for_confirmation() {
        confirmation_msg=$1

        if [ -n "${confirmation_msg}" ]; then
            printf "%s\\n(y/n and press Enter)\\n" "${confirmation_msg}"
        else
            printf "Confirm action: (y/n and press Enter)\\n"
        fi
        read -r answer </dev/tty

        if [ "${answer}" != "${answer#[Yy]}" ]; then
            return 0
        else
            return 1
        fi

        unset confirmation_msg answer
    }

    ##############################################
    #--[ Command line parsing and entry point ]--#
    ##############################################

    [ $# -lt 1 ] && usage

    while [ $# -gt 0 ]; do
        case $1 in
        -v | --verbose)
            VERBOSE=true
            shift 1
            if [ $# -lt 1 ]; then
                usage
            fi
            ;;
        -V | --version)
            printf "%s\\n" "${VERSION}"
            exit 0
            ;;
        -B | --base)
            if [ $# -lt 3 ]; then
                usage
            fi
            BASE_URL="$2"
            shift 2
            ;;
        --list-commands)
            echo "install
list
rm
update"
            exit 0
            ;;
        -h | --help)
            usage
            ;;

        *)

            # check for available commands
            missing_commands="$(check_required_commands)"
            if [ -n "${missing_commands}" ]; then
                die "Following commands are required, but missing, please install: ${missing_commands}"
            fi
            unset missing_commands

            case $1 in
            init)
                shift 1
                [ "$1" == "-h" -o "$1" == "--help" ] && init_usage
                CREATING_EPM_HOME=true
                MODIFYING_EPM_HOME=true
                EPM_HOME=$(pwd)
                init_epm_home
                install_pkgs "$@"
                break
                ;;
            install | i)
                shift 1
                [ "$1" == "-h" -o "$1" == "--help" ] && install_usage
                CREATING_EPM_HOME=true
                MODIFYING_EPM_HOME=true
                locate_epm_home || die "No writable EPM home to install packages"
                install_pkgs "$@"
                break
                ;;
            list | l)
                shift 1
                locate_epm_home || die "No EPM home to show"
                while [ $# -gt 0 ]; do
                    case $1 in
                    -h | --help) list_usage ;;
                    -u | --upstream)
                        SHOW_REPO=true
                        shift 1
                        ;;
                    -b | --branch)
                        SHOW_BRANCH=true
                        shift 1
                        ;;
                    -m | --modules)
                        SHOW_MODULES=true
                        shift 1
                        ;;
                    *) list_usage ;;
                    esac
                done
                list_pkgs
                break
                ;;
            with | w)
                shift 1
                [ $# -lt 1 ] && with_usage
                MODIFYING_EPM_HOME=true
                locate_epm_home || die "No workable EPM home"
                case $1 in
                -h | --help) with_usage ;;
                esac
                with_pkg "$@"
                break
                ;;
            run | exec | x)
                shift 1
                locate_epm_home || die "No EPM home for the run"
                [ $# -lt 1 ] && epm_exec_usage
                case $1 in
                -h | --help) epm_exec_usage ;;
                esac
                epm_exec "$@"
                break
                ;;
            update | up | u)
                shift 1
                [ $# -gt 0 ] && update_usage
                MODIFYING_EPM_HOME=true
                locate_epm_home || die "No modifiable EPM home to update"
                cd "${EPM_HOME}"
                update_pkgs
                break
                ;;
            rm)
                shift 1
                MODIFYING_EPM_HOME=true
                locate_epm_home || die "No modifiable EPM home to remove packages"

                PKGS2RM=""
                while [ $# -gt 0 ]; do
                    case $1 in
                    -h | --help) rm_usage ;;
                    -f | --force)
                        FORCE=true
                        shift 1
                        ;;
                    *)
                        PKGS2RM="${PKGS2RM} $1"
                        shift 1
                        ;;
                    esac
                done
                [ -n "${PKGS2RM}" ] && rm_pkgs ${PKGS2RM} || rm_usage
                break
                ;;
            *) usage ;;
            esac
            break
            ;;
        esac
    done

)
