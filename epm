#!/usr/bin/env bash

# safety subshell to avoid executing anything in case this script is not downloaded properly
(

    ##########################
    #--[ Global Variables ]--#
    ##########################

    # @VARIABLE: VERSION
    # @DESCRIPTION:
    # Version of this script.
    VERSION=0.1.1

    # Default base URL for short package names
    BASE_URL=${EPM_REPO_BASE:-"https://github.com/e-wrks"}

    # @VARIABLE: SCRIPT
    # @DESCRIPTION:
    # Name of this script. This will be the
    # shell name if this script is sourced, so
    # only rely on this for echos and trivial things.
    SCRIPT="$(basename "$0")"

    # the nearest home directory for local packages
    EPM_HOME="Yet-Discovered"
    # all effective epm home's bin directory separated by colon (:)
    EPM_PATH=""

    init_epm_home() {
        (
            [ -w "${EPM_HOME}/edh_modules" ] || edo mkdir "${EPM_HOME}/edh_modules"
            [ -w "${EPM_HOME}/edh-universe/bin" ] || edo mkdir -p "${EPM_HOME}/edh-universe/bin"
            update_stack_packages
        ) || die "Can NOT create EPM home artifacts in [${EPM_HOME}]"
    }

    locate_epm_home() {

        locate_home_at() { (
            parent_dir=$(dirname "$1")
            if [ "${parent_dir}" == "$1" ]; then
                ppath=""
            else
                ppath=$(locate_home_at "${parent_dir}")
            fi
            if [ -x "$1"/edh-universe/bin ]; then
                if [ -n "${ppath}" ]; then
                    echo "$1"/edh-universe/bin:"${ppath}"
                else
                    echo "$1"/edh-universe/bin
                fi
            else
                echo "${ppath}"
            fi

        ); }

        EPM_PATH=$(locate_home_at "$(pwd)")
        EPM_HOME="${EPM_PATH%%/edh-universe/bin*}"

        if [ -e "${EPM_HOME}" ]; then
            if [ ! -d "${EPM_HOME}" ]; then
                die "Not a directory: ${EPM_HOME}"
            elif [ -w "${EPM_HOME}" ]; then
                status_message " >> Managing packages at EPM home [${EPM_HOME}] <<"
            elif ${MODIFYING_EPM_HOME}; then
                red_message " >> Readonly EPM home at [${EPM_HOME}] <<"
                return 1
            fi
        elif ${CREATING_EPM_HOME}; then
            EPM_HOME=$(pwd)
            warning_message "Creating new EPM home at [${EPM_HOME}] ..."
            init_epm_home
            if [ -n "${EPM_PATH}" ]; then
                EPM_PATH="${EPM_HOME}/edh-universe/bin:${EPM_PATH}"
            else
                EPM_PATH="${EPM_HOME}/edh-universe/bin"
            fi
        else
            warning_message "No effective EPM home for directory [$(pwd)]"
            return 1
        fi

        export EPM_PATH EPM_HOME
    }

    update_stack_packages() { (
        cd "${EPM_HOME}"
        (
            if [ -f "stack.yaml" ]; then
                while IFS= read -r line; do
                    [ "${line}" == '## FOLLOWING CONTENTS GONNA BE OVERWRITTEN BY EPM ##' ] && break
                    echo "$line"
                done <"stack.yaml"
            else
                echo ''
                echo "# Please change the resolver and other Stack settings per your needs"
                echo 'resolver: lts-15.15'
            fi
            echo ''
            echo '## FOLLOWING CONTENTS GONNA BE OVERWRITTEN BY EPM ##'
            echo ''
            echo "local-bin-path: edh-universe/bin"
            echo 'packages:'
            find edh-universe -name \*.cabal | while read -r fn; do
                echo " - $(dirname "${fn}")"
            done
        ) >"_new_stack.yaml"
        edo mv -f "_new_stack.yaml" "stack.yaml"
    ); }

    # whether we tend to create an EPM home
    CREATING_EPM_HOME=false
    # whether we tend to modify an EPM home
    MODIFYING_EPM_HOME=false
    # whether build Haskell source by EPM
    EPM_BUILD_HS=false

    # @VARIABLE: VERBOSE
    # @DESCRIPTION:
    # Whether to print verbose messages in this script.
    VERBOSE=false

    # @VARIABLE: FORCE
    # @DESCRIPTION:
    # Whether to force installation and overwrite files.
    FORCE=false

    # options in listing subcommand
    SHOW_REPO=false
    SHOW_BRANCH=false
    SHOW_MODULES=false

    ####################
    #--[ Print Help ]--#
    ####################

    # @FUNCTION: usage
    # @DESCRIPTION:
    # Print the help message for 'epm' to STDERR
    # and exit the script with status code 1.
    usage() {
        (echo >&2 "epm ${VERSION} >> Edh Package Manager <<

USAGE:
    ${SCRIPT} [FLAGS] <SUBCOMMAND>

FLAGS:
    -v, --verbose         Enable verbose output
    -h, --help            Prints help information
    -V, --version         Prints version information
    -B, --base <URL>      URL prefix for upstream package repositories
                    default:  ${BASE_URL}
                    environment variable EPM_REPO_BASE overrides above

SUBCOMMANDS:
    init                  Initialize current working directory as an EPM home
    install    | i        Install new, or change branches of existing packages 
    list       | l        List homes and packages
    update     | u        Pull upstream changes of packages from tracked branches
    with       | w        Run command within the directory of a package
    run | exec | x        Run command with all effective EPM home's bin on \$PATH
    rm                    Remove specified package(s) from nearest EPM home
")
        exit 1
    }

    # @FUNCTION: install_usage
    # @DESCRIPTION:
    # Print the help message for 'epm install' to STDERR
    # and exit the script with status code 1.
    install_usage() {
        (echo >&2 "epm-install
Install packages as specified

USAGE:
    ${SCRIPT} install [FLAGS] [ -b <branch> ] [ <PKGn> | <URLn> ] [ -B <URL1> <PKG1> <PKG2> ... ] [ -B <URL2> <PKG3> ... ]

FLAGS:
    -h, --help            Prints help information

ARGS:
    -b <branch>           Branch to checkout and track
                only applies to the immediately following package
                default: master
    -B, --base <URL>      URL prefix for upstream package repositories
                    default:  ${BASE_URL}
                    environment variable EPM_REPO_BASE overrides above
    <PKGn>                E.g. nedh or sedh
    <URLn>                E.g. \"https://github.com/e-wrks/hasdb\"

EXAMPLES:
    epm install -b 0.3 edh -b 0.1 nedh -B https://git.corporate.lan -b golden esb/cord -b qa esb/mart
")
        exit 1
    }

    # @FUNCTION: with_usage
    # @DESCRIPTION:
    # Print the help message for 'epm with' to STDERR
    # and exit the script with status code 1.
    with_usage() {
        (echo >&2 "epm-with
Run command within the directory of a package

USAGE:
    ${SCRIPT} with [FLAGS] <PKG> [ <CMD> [ <ARG1> <ARG2> ... ] ]

FLAGS:
    -h, --help              Prints help information

ARGS:
    <PKG>                   E.g. \"nedh\" or \"sedh\"
    <CMD> [ <ARGn> ... ]    E.g. \"cabal run edhi\" or \"caban install edhi\"
                         default: bash
")
        exit 1
    }

    # @FUNCTION: epm_exec_usage
    # @DESCRIPTION:
    # Print the help message for 'epm run' to STDERR
    # and exit the script with status code 1.
    epm_exec_usage() {
        (echo >&2 "epm-run
Run command with all effective EPM home's bin on \$PATH

USAGE:
    ${SCRIPT} run [FLAGS] <CMD> [ <ARG1> <ARG2> ... ]

FLAGS:
    -h, --help              Prints help information

ARGS:
    <CMD> [ <ARGn> ... ]    E.g. edhi or bash
")
        exit 1
    }

    # @FUNCTION: rm_usage
    # @DESCRIPTION:
    # Print the help message for 'epm rm' to STDERR
    # and exit the script with status code 1.
    rm_usage() {
        (echo >&2 "epm-rm
Remove the specified packages installed by epm

USAGE:
    ${SCRIPT} rm [FLAGS] <PKG1> [ <PKG2> ... ]

FLAGS:
    -h, --help       Prints help information

ARGS:
    <PKGn>           E.g. \"nedh\" or \"sedh\"
")
        exit 1
    }

    # @FUNCTION: list_usage
    # @DESCRIPTION:
    # Print the help message for 'epm list' to STDERR
    # and exit the script with status code 1.
    list_usage() {
        (echo >&2 "epm-list
Show locally installed packages

USAGE:
    ${SCRIPT} list

FLAGS:
    -h, --help             Prints help information
    -u, --upstream         Show repository URL
    -b, --branch           Show branches
    -m, --modules          List Edh modules
")
        exit 1
    }

    ############################
    #--[ Subcommand install ]--#
    ############################

    # @FUNCTION: install_pkg
    # @USAGE: <PKG>
    # @DESCRIPTION:
    # Installs the specified package
    install_pkg() {
        if [ "${1#*://}" == "$1" ]; then
            full_url="${BASE_URL}/$1"
        else
            full_url="$1"
        fi
        pkg_id=${full_url#*://*/}
        pkg_dir=edh-universe/"${pkg_id}"

        status_message "Installing $1 to ${pkg_dir} ..."
        (
            if [ -d "${pkg_dir}" ]; then
                edo pushd "${pkg_dir}" >/dev/null
                edo git checkout -f -B "${BRANCH:-master}"
                edo popd >/dev/null
            else
                edo git clone -b "${BRANCH:-master}" "${full_url}" "${pkg_dir}"
            fi
        ) || die "Failed cloning ${full_url} to ${pkg_dir}"

        (
            edo pushd edh_modules >/dev/null
            for a in ../"${pkg_dir}"/edh_modules/*; do
                b=$(basename "$a")
                [ -e "./$b" ] && edo rm -rf "./$b"
                edo ln -s "$a" "$b"
            done
            edo popd >/dev/null
        ) || die "Failed linking Edh module artifacts"

        ${EPM_BUILD_HS} && ( (
            edo pushd "${pkg_dir}" >/dev/null
            status_message "Building Haskell components for ${pkg_id} ..."
            edo cabal build all
            edo popd >/dev/null
        ) || red_message "Failed building Haskell components for ${pkg_id}")

        status_message "Installed $1 ."

        unset full_url pkg_id pkg_dir a b
    }

    #########################
    #--[ Subcommand list ]--#
    #########################

    # @FUNCTION: list
    # @USAGE: <tool> <raw-format> <criteria>
    # @DESCRIPTION:
    # List local packages installed by epm
    list_pkgs() { (
        IFS=: ps=(${EPM_PATH})
        for p in ${ps[@]}; do
            EPM_HOME=${p%%/edh-universe/bin}
            status_message "  > EPM home at [${EPM_HOME}] <"
            cd "${EPM_HOME}"
            find edh-universe -name edh_modules | while read -r pkg_dir1; do
                pkg_dir="${pkg_dir1%/edh_modules}"
                pkg_id="${pkg_dir#edh-universe/}"
                (
                    edo pushd "${pkg_dir}" >/dev/null
                    echo "${pkg_id} - $(git describe --all --dirty --broken)"
                    if ${SHOW_REPO}; then
                        echo " - From: $(
                            git config remote.$(git config branch.$(git branch --format '%(refname:short)').remote).url
                        )"
                    fi
                    if ${SHOW_BRANCH}; then
                        echo " - Branch: $(edo git branch -vv)"
                    fi
                    if ${SHOW_MODULES}; then
                        echo " - Modules:"
                        find edh_modules -type f | while read -r modu; do
                            echo "    ${modu}"
                        done
                    fi
                    edo popd >/dev/null
                ) || die "Failed browsing package ${pkg_id}"
            done
        done
    ); }

    #########################
    #--[ Subcommand with ]--#
    #########################

    # Run command in a package's directory
    with_pkg() { (
        pkg="$1"
        shift 1
        IFS=: ps=(${EPM_PATH})
        for p in ${ps[@]}; do
            EPM_HOME=${p%%/edh-universe/bin}
            cd "${EPM_HOME}"
            pkg_dir=$(
                find edh-universe -name edh_modules | while read -r pkg_dir1; do
                    pkg_dir="${pkg_dir1%/edh_modules}"
                    pkg_id="${pkg_dir#edh-universe/}"
                    [ "${pkg_id%/${pkg}}" != "${pkg_id}" ] && echo "${pkg_dir}"
                done
            )
            if [ -d "${pkg_dir}" ]; then
                # implant `--overwrite-policy=always --installdir=${EPM_HOME}/edh-universe/bin`
                # to `cabal install` cmdl, magically !
                if [ "$1" == "cabal" -a "$2" == "install" ]; then
                    shift 2
                    set -- cabal install --overwrite-policy=always --installdir=${EPM_HOME}/edh-universe/bin "$@"
                elif [ $# -lt 1 ]; then
                    set -- bash
                fi

                pkg_id="${pkg_dir#edh-universe/}"
                status_message " >> With Edh package [${pkg_id}] in EPM home [${EPM_HOME}] <<"
                edo pushd "${pkg_dir}" >/dev/null
                export PATH="${EPM_PATH}":"${PATH}"
                exec $*
                edo popd >/dev/null
                red_message "You've been kicked back."
            fi
        done
        warning_message "No such package [${pkg}] in any effective EPM home"
    ); }

    #########################
    #--[ Subcommand run ]--#
    #########################

    # Run command with all effective EPM home's bin on $PATH
    epm_exec() {
        export PATH="${EPM_PATH}":"${PATH}"
        exec $*
        red_message "You've been kicked back."
    }

    #########################
    #--[ Subcommand update ]--#
    #########################

    # Update local packages installed by epm
    update_pkgs() { (
        cd "${EPM_HOME}"
        find edh-universe -name edh_modules | while read -r pkg_dir1; do
            pkg_dir="${pkg_dir1%/edh_modules}"
            pkg_id="${pkg_dir#edh-universe/}"

            status_message "Updating ${pkg_id}"

            (
                edo pushd "${pkg_dir}" >/dev/null
                edo git pull
                edo popd >/dev/null
            ) || die "Failed updating package ${pkg_id}"

            (
                find edh_modules -type l | while read -r modu_root; do
                    mr_path=$(readlink "${modu_root}")
                    if [ "${mr_path#../${pkg_dir1}/}" != "${mr_path}" ]; then
                        edo rm "${modu_root}" || die "Failed unlink ${modu_root}"
                    fi
                done

                edo pushd edh_modules >/dev/null
                for a in ../"${pkg_dir}"/edh_modules/*; do
                    b=$(basename "$a")
                    [ -e "./$b" ] && edo rm -rf "./$b"
                    edo ln -s "$a" "$b"
                done
                edo popd >/dev/null
            ) || die "Failed re-linking Edh module artifacts"

            ${EPM_BUILD_HS} && ( (
                edo pushd "${pkg_dir}" >/dev/null
                status_message "Building Haskell components for ${pkg_id} ..."
                edo cabal build all
                edo popd >/dev/null
            ) || red_message "Failed building Haskell components for ${pkg_id}")
        done
    ); }

    #######################
    #--[ Subcommand rm ]--#
    #######################

    # @FUNCTION: rm_pkgs
    # @USAGE: <ghcversion>
    # @DESCRIPTION:
    # Removes the specified package(s) installed by epm.
    rm_pkgs() { (
        cd "${EPM_HOME}"
        find edh-universe -name edh_modules | while read -r pkg_dir1; do
            pkg_dir="${pkg_dir1%/edh_modules}"
            pkg_id="${pkg_dir#edh-universe/}"
            edo pushd "${pkg_dir}" >/dev/null
            pkg_repo="$(
                git config remote.$(git config branch.$(git branch --format '%(refname:short)').remote).url
            )"
            edo popd >/dev/null
            for name2rm in "$@"; do
                if [ "${pkg_id%/${name2rm}}" != "${pkg_id}" ]; then
                    warning_message "Package [${pkg_id}] has upstream ${pkg_repo}"
                    if ask_for_confirmation "Remove it from [${EPM_HOME}] ?"; then
                        status_message "Removing ${pkg_dir} ..."
                        find edh_modules -type l | while read -r modu_root; do
                            mr_path=$(readlink "${modu_root}")
                            if [ "${mr_path#../${pkg_dir1}/}" != "${mr_path}" ]; then
                                edo rm "${modu_root}" || die "Failed unlink ${modu_root}"
                            fi
                        done
                        edo rm -rf "${pkg_dir}"
                    fi
                fi
            done
        done
        update_stack_packages
    ); }

    ###########################
    #--[ Utility functions ]--#
    ###########################

    # @FUNCTION: die
    # @USAGE: [msg]
    # @DESCRIPTION:
    # Exits the shell script with status code 2
    # and prints the given message in red to STDERR, if any.
    die() {
        (red_message >&2 "$1")
        exit 2
    }

    # @FUNCTION: edo
    # @USAGE: <command>
    # @DESCRIPTION:
    # Executes the given command. Also prints what
    # command that is (in blue) if verbosity is enabled.
    # Exits with status code 2 if the command failed.
    edo() {
        if ${VERBOSE}; then
            printf "\\033[0;34m%s\\033[0m\\n" "$*" 1>&2
        fi
        "$@" || exit 2
    }

    # @FUNCTION: debug_message
    # @USAGE: <msg>
    # @DESCRIPTION:
    # Print a blue debug message if verbosity is enabled.
    debug_message() {
        if ${VERBOSE}; then
            (printf >&2 "\\033[0;34m%s\\033[0m\\n" "$1")
        fi
    }

    # @FUNCTION: optionv
    # @USAGE: <arg1> [arg2]
    # @DESCRIPTION:
    # If verbosity is enabled, echo the first argument, otherwise
    # the second (if any).
    # @STDOUT: first or second argument
    optionv() {
        if ${VERBOSE}; then
            echo "$1"
        else
            if [ -n "$2" ]; then
                echo "$2"
            fi
        fi
    }

    # @FUNCTION: status_message
    # @USAGE: <msg>
    # @DESCRIPTION:
    # Print a green status message.
    status_message() {
        printf "\\033[0;32m%s\\033[0m\\n" "$1"
    }

    # @FUNCTION: warning_message
    # @USAGE: <msg>
    # @DESCRIPTION:
    # Print a yellow warning message.
    warning_message() {
        printf "\\033[1;33m%s\\033[0m\\n" "$1"
    }

    # @FUNCTION: red_message
    # @USAGE: <msg>
    # @DESCRIPTION:
    # Print a red message.
    red_message() {
        printf "\\033[0;31m%s\\033[0m\\n" "$1"
    }

    # @FUNCTION: command_exists
    # @USAGE: <command>
    # @DESCRIPTION:
    # Check if a command exists (no arguments).
    # @RETURNS: 0 if the command exists, non-zero otherwise
    command_exists() {
        [ -z "$1" ] && die "Internal error: no argument given to command_exists"

        command -V "$1" >/dev/null 2>&1
        return $?
    }

    # @FUNCTION: check_required_commands
    # @USAGE: [additional-commands]
    # @DESCRIPTION:
    # Check that all required commands for this script exist.
    # @STDOUT: The commands that do not exist
    # @RETURNS: 0 if all command exists, non-zero otherwise
    check_required_commands() {
        _missing_commands=

        for com in "$@" basename dirname find git; do
            command_exists "${com}" || {
                _missing_commands="${_missing_commands} ${com}"
            }
        done
        unset com

        if [ -n "${_missing_commands}" ]; then
            printf "%s" "${_missing_commands}"
            unset _missing_commands
            return 1
        else
            unset _missing_commands
            return 0
        fi
    }

    # @FUNCTION: ask_for_confirmation
    # @USAGE: [confirmation-msg]
    # @DESCRIPTION:
    # Asks the user for confirmation and returns 0 for yes, 1 for no.
    # @RETURN: 0 if user confirmed, 1 otherwise
    ask_for_confirmation() {
        confirmation_msg=$1

        if [ -n "${confirmation_msg}" ]; then
            printf "%s\\n(y/n and press Enter)\\n" "${confirmation_msg}"
        else
            printf "Confirm action: (y/n and press Enter)\\n"
        fi
        read -r answer </dev/tty

        if [ "${answer}" != "${answer#[Yy]}" ]; then
            return 0
        else
            return 1
        fi

        unset confirmation_msg answer
    }

    ##############################################
    #--[ Command line parsing and entry point ]--#
    ##############################################

    [ $# -lt 1 ] && usage

    while [ $# -gt 0 ]; do
        case $1 in
        -v | --verbose)
            VERBOSE=true
            shift 1
            if [ $# -lt 1 ]; then
                usage
            fi
            ;;
        -V | --version)
            printf "%s\\n" "${VERSION}"
            exit 0
            ;;
        -B | --base)
            if [ $# -lt 3 ]; then
                usage
            fi
            BASE_URL="$2"
            shift 2
            ;;
        --list-commands)
            echo "install
list
rm
update"
            exit 0
            ;;
        -h | --help)
            usage
            ;;

        *)

            # check for available commands
            missing_commands="$(check_required_commands)"
            if [ -n "${missing_commands}" ]; then
                die "Following commands are required, but missing, please install: ${missing_commands}"
            fi
            unset missing_commands

            case $1 in
            init)
                CREATING_EPM_HOME=true
                MODIFYING_EPM_HOME=true
                EPM_HOME=$(pwd)
                init_epm_home
                break
                ;;
            install | i)
                shift 1
                CREATING_EPM_HOME=true
                MODIFYING_EPM_HOME=true
                locate_epm_home || die "No writable EPM home to install packages"
                cd "${EPM_HOME}"
                while [ $# -gt 0 ]; do
                    case $1 in
                    -h | --help) install_usage ;;
                    -B | --base)
                        if [ $# -lt 2 ]; then
                            install_usage
                        fi
                        BASE_URL="$2"
                        shift 2
                        ;;
                    -b)
                        BRANCH="$1"
                        shift 1
                        ;;
                    *)
                        install_pkg "$1"
                        # -b has to be specified per pkg
                        unset BRANCH
                        shift 1
                        ;;
                    esac
                done
                update_stack_packages
                break
                ;;
            list | l)
                shift 1
                locate_epm_home || die "No EPM home to show"
                while [ $# -gt 0 ]; do
                    case $1 in
                    -h | --help) list_usage ;;
                    -u | --upstream)
                        SHOW_REPO=true
                        shift 1
                        ;;
                    -b | --branch)
                        SHOW_BRANCH=true
                        shift 1
                        ;;
                    -m | --modules)
                        SHOW_MODULES=true
                        shift 1
                        ;;
                    *) list_usage ;;
                    esac
                done
                list_pkgs
                break
                ;;
            with | w)
                shift 1
                [ $# -lt 1 ] && with_usage
                MODIFYING_EPM_HOME=true
                locate_epm_home || die "No workable EPM home"
                case $1 in
                -h | --help) with_usage ;;
                esac
                with_pkg "$@"
                break
                ;;
            run | exec | x)
                shift 1
                locate_epm_home || die "No EPM home for the run"
                [ $# -lt 1 ] && epm_exec_usage
                case $1 in
                -h | --help) epm_exec_usage ;;
                esac
                epm_exec "$@"
                break
                ;;
            update | u)
                MODIFYING_EPM_HOME=true
                locate_epm_home || die "No modifiable EPM home to update"
                cd "${EPM_HOME}"
                update_pkgs
                break
                ;;
            rm)
                shift 1
                MODIFYING_EPM_HOME=true
                locate_epm_home || die "No modifiable EPM home to remove packages"

                PKGS2RM=""
                while [ $# -gt 0 ]; do
                    case $1 in
                    -h | --help) rm_usage ;;
                    -f | --force)
                        FORCE=true
                        shift 1
                        ;;
                    *)
                        PKGS2RM="${PKGS2RM} $1"
                        shift 1
                        ;;
                    esac
                done
                [ -n "${PKGS2RM}" ] && rm_pkgs ${PKGS2RM} || rm_usage
                break
                ;;
            *) usage ;;
            esac
            break
            ;;
        esac
    done

)
