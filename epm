#!/usr/bin/env bash

# safety subshell to avoid executing anything in case this script is not downloaded properly
(

    ##########################
    #--[ Global Variables ]--#
    ##########################


# @VARIABLE: VERSION
# @DESCRIPTION:
# Version of this script.
VERSION=0.0.1


# local package directory
PKG_DIR="$(pwd)"

# Default base URL for short package names
BASE_URL="https://github.com/e-wrks"

SHOW_REPO=false
SHOW_BRANCH=false
SHOW_MODULES=false


# @VARIABLE: SCRIPT
# @DESCRIPTION:
# Name of this script. This will be the
# shell name if this script is sourced, so
# only rely on this for echos and trivial things.
SCRIPT="$(basename "$0")"

# @VARIABLE: VERBOSE
# @DESCRIPTION:
# Whether to print verbose messages in this script.
VERBOSE=false

# @VARIABLE: FORCE
# @DESCRIPTION:
# Whether to force installation and overwrite files.
FORCE=false


    ####################
    #--[ Print Help ]--#
    ####################


# @FUNCTION: usage
# @DESCRIPTION:
# Print the help message for 'epm' to STDERR
# and exit the script with status code 1.
usage() {
    (>&2 echo "epm ${VERSION}
Edh Package Manager

USAGE:
    ${SCRIPT} [FLAGS] <SUBCOMMAND>

FLAGS:
    -v, --verbose         Enable verbose output
    -h, --help            Prints help information
    -V, --version         Prints version information
    -b, --base <url>      URL prefix for short package names

SUBCOMMANDS:
    install            Install packages
    list               List packages
    update             Pull tracked branch for all packages
    rm                 Remove installed packages
")
    exit 1
}

# @FUNCTION: install_usage
# @DESCRIPTION:
# Print the help message for 'epm install' to STDERR
# and exit the script with status code 1.
install_usage() {
    (>&2 echo "epm-install
Install packages as specified

USAGE:
    ${SCRIPT} install [FLAGS] [NAME|URL] [NAME|URL] ...

FLAGS:
    -h, --help            Prints help information
    -f, --force           Overwrite already existing installation
    -b, --base <url>      URL prefix for short package names

ARGS:
    [NAME|URL]    E.g. \"nedh\" or \"sedh\" or
                     a url like \"https://github.com/e-wrks/hasdb\"
                     (default: edh)
")
    exit 1
}

# @FUNCTION: rm_usage
# @DESCRIPTION:
# Print the help message for 'epm rm' to STDERR
# and exit the script with status code 1.
rm_usage() {
    (>&2 echo "epm-rm
Remove the specified packages installed by epm

USAGE:
    ${SCRIPT} rm [FLAGS] [NAME] [NAME] ...

FLAGS:
    -h, --help       Prints help information
    -f, --force      Don't prompt user

ARGS:
    <NAME>        E.g. \"nedh\" or \"sedh\"
")
    exit 1
}


# @FUNCTION: list_usage
# @DESCRIPTION:
# Print the help message for 'epm list' to STDERR
# and exit the script with status code 1.
list_usage() {
    (>&2 echo "epm-list
Show locally installed packages

USAGE:
    ${SCRIPT} list

FLAGS:
    -h, --help             Prints help information
    -u, --upstream         Show repository URL
    -b, --branch           Show branches
    -m, --modules          List Edh modules
")
    exit 1
}


    ############################
    #--[ Subcommand install ]--#
    ############################

# @FUNCTION: install_pkgs
# @USAGE: [NAME1] [NAME2] ...
# @DESCRIPTION:
# Installs the specified packages
install_pkgs() {
    if [ $# -lt 1 ]; then
        install_pkgs edh
    else
        for pkg in "$@"; do
            install_pkg "${pkg}"
        done
    fi
}

install_pkg() {
    FULL_URL="${BASE_URL}/$1"
    PKG_ID=${FULL_URL#*://*/}
    PKG_DIR=edh-universe/"${PKG_ID}"

    status_message "Installing $1 to ${PKG_DIR} ..."
    (
        test -d "${PKG_DIR}" || edo git clone "${FULL_URL}" "${PKG_DIR}"
    ) || die "Failed cloning ${FULL_URL} to ${PKG_DIR}"
    (
        edo pushd edh_modules >/dev/null
        for a in ../"${PKG_DIR}"/edh_modules/*; do
            b=$(basename "$a")
            edo rm -rf "./$b"
            edo ln -s "$a" "$b"
        done
        edo popd >/dev/null
    ) || die "Failed linking Edh module artifacts"

    status_message "Installed $1 ."
}


    #########################
    #--[ Subcommand list ]--#
    #########################

# @FUNCTION: list
# @USAGE: <tool> <raw-format> <criteria>
# @DESCRIPTION:
# List local packages installed by epm
list_pkgs() {
    find edh-universe -name edh_modules | while read PKG_DIR1; do
        PKG_DIR="${PKG_DIR1%/edh_modules}"
        PKG_ID="${PKG_DIR#edh-universe/}"
        echo "${PKG_ID}"
        (
            edo pushd "${PKG_DIR}" >/dev/null
            if ${SHOW_REPO}; then
                echo " - From: $(
                    git config remote.$(git config branch.$(git branch --format '%(refname:short)').remote).url
                )"
            fi
            if ${SHOW_BRANCH}; then
                echo " - Branch: $(edo git branch -vv)"
            fi
            if ${SHOW_MODULES}; then
                echo " - Modules:"
                find edh_modules -type f | while read MODU; do
                    echo "    ${MODU}"
                done
            fi
            edo popd >/dev/null
        ) || die "Failed browsing package ${PKG_ID}"
    done
}


    #########################
    #--[ Subcommand update ]--#
    #########################

# Update local packages installed by epm
update_pkgs() {
    find edh-universe -name edh_modules | while read PKG_DIR1; do
        PKG_DIR="${PKG_DIR1%/edh_modules}"
        PKG_ID="${PKG_DIR#edh-universe/}"
        status_message "Updating ${PKG_ID}"
        (
            edo pushd "${PKG_DIR}" >/dev/null
            edo git pull
            edo popd >/dev/null
        ) || die "Failed updating package ${PKG_ID}"
    done
}


    #######################
    #--[ Subcommand rm ]--#
    #######################

# @FUNCTION: rm_pkgs
# @USAGE: <ghcversion>
# @DESCRIPTION:
# Removes the specified packages installed by epm.
rm_pkgs() {
    find edh-universe -name edh_modules | while read PKG_DIR1; do
        PKG_DIR="${PKG_DIR1%/edh_modules}"
        PKG_ID="${PKG_DIR#edh-universe/}"
        edo pushd "${PKG_DIR}" >/dev/null
        PKG_REPO="$(
            git config remote.$(git config branch.$(git branch --format '%(refname:short)').remote).url
        )"
        edo popd >/dev/null
        for NAME2RM in "$@"; do
            if [ "${PKG_ID%/${NAME2RM}}" != "${PKG_ID}" ]; then
                if ask_for_confirmation "Remove [${PKG_ID}] from ${PKG_REPO} ?"; then
                    status_message "Removing ${PKG_DIR} ..."
                    find edh_modules -type l | while read MODU_ROOT; do
                        MR_PATH=$(readlink "${MODU_ROOT}")
                        if [ "${MR_PATH#../${PKG_DIR1}/}" != "${MR_PATH}" ]; then
                            echo "${MR_PATH#../${PKG_DIR1}/}  vs  ${MR_PATH}"
                            edo rm "${MODU_ROOT}" || die "Failed unlink ${MODU_ROOT}"
                        fi
                    done
                    edo rm -rf "${PKG_DIR}"
                fi
            fi
        done
    done
}


    ###########################
    #--[ Utility functions ]--#
    ###########################


# @FUNCTION: die
# @USAGE: [msg]
# @DESCRIPTION:
# Exits the shell script with status code 2
# and prints the given message in red to STDERR, if any.
die() {
    (>&2 red_message "$1")
    exit 2
}

# @FUNCTION: edo
# @USAGE: <command>
# @DESCRIPTION:
# Executes the given command. Also prints what
# command that is (in blue) if verbosity is enabled.
# Exits with status code 2 if the command failed.
edo()
{
    if ${VERBOSE} ; then
        printf "\\033[0;34m%s\\033[0m\\n" "$*" 1>&2
    fi
    "$@" || exit 2
}

# @FUNCTION: debug_message
# @USAGE: <msg>
# @DESCRIPTION:
# Print a blue debug message if verbosity is enabled.
debug_message() {
    if ${VERBOSE} ; then
        (>&2 printf "\\033[0;34m%s\\033[0m\\n" "$1")
    fi
}

# @FUNCTION: optionv
# @USAGE: <arg1> [arg2]
# @DESCRIPTION:
# If verbosity is enabled, echo the first argument, otherwise
# the second (if any).
# @STDOUT: first or second argument
optionv() {
    if ${VERBOSE} ; then
        echo "$1"
    else
        if [ -n "$2" ] ; then
            echo "$2"
        fi
    fi
}

# @FUNCTION: status_message
# @USAGE: <msg>
# @DESCRIPTION:
# Print a green status message.
status_message() {
    printf "\\033[0;32m%s\\033[0m\\n" "$1"
}

# @FUNCTION: warning_message
# @USAGE: <msg>
# @DESCRIPTION:
# Print a yellow warning message.
warning_message() {
    printf "\\033[1;33m%s\\033[0m\\n" "$1"
}

# @FUNCTION: red_message
# @USAGE: <msg>
# @DESCRIPTION:
# Print a red message.
red_message() {
    printf "\\033[0;31m%s\\033[0m\\n" "$1"
}

# @FUNCTION: command_exists
# @USAGE: <command>
# @DESCRIPTION:
# Check if a command exists (no arguments).
# @RETURNS: 0 if the command exists, non-zero otherwise
command_exists() {
    [ -z "$1" ] && die "Internal error: no argument given to command_exists"

    command -V "$1" >/dev/null 2>&1
    return $?
}

# @FUNCTION: check_required_commands
# @USAGE: [additional-commands]
# @DESCRIPTION:
# Check that all required commands for this script exist.
# @STDOUT: The commands that do not exist
# @RETURNS: 0 if all command exists, non-zero otherwise
check_required_commands() {
    _missing_commands=

    for com in "$@" basename dirname git; do
        command_exists "${com}" || {
            _missing_commands="${_missing_commands} ${com}"
        }
    done
    unset com

    if [ -n "${_missing_commands}" ] ; then
        printf "%s" "${_missing_commands}"
        unset _missing_commands
        return 1
    else
        unset _missing_commands
        return 0
    fi
}

# @FUNCTION: ask_for_confirmation
# @USAGE: [confirmation-msg]
# @DESCRIPTION:
# Asks the user for confirmation and returns 0 for yes, 1 for no.
# @RETURN: 0 if user confirmed, 1 otherwise
ask_for_confirmation() {
    confirmation_msg=$1

    if [ -n "${confirmation_msg}" ] ; then
        printf "%s\\n(y/n and press Enter)\\n" "${confirmation_msg}"
    else
        printf "Confirm action: (y/n and press Enter)\\n"
    fi
    read -r answer </dev/tty

    if [ "${answer}" != "${answer#[Yy]}" ] ;then
        return 0
    else
        return 1
    fi

    unset confirmation_msg answer
}


    ##############################################
    #--[ Command line parsing and entry point ]--#
    ##############################################

[ $# -lt 1 ] && usage

while [ $# -gt 0 ] ; do
    case $1 in
    -v|--verbose)
        VERBOSE=true
        shift 1
        if [ $# -lt 1 ] ; then
            usage
        fi
        ;;
    -V|--version)
        printf "%s\\n" "${VERSION}"
        exit 0;;
    -b|--base)
        if [ $# -lt 3 ] ; then
            usage
        fi
        BASE_URL="$2"
        shift 2
        ;;
    --list-commands)
        echo "install
list
rm
update"
        exit 0;;
    -h|--help)
        usage;;

    *) ## startup tasks ##

       (
        test -w edh_modules || edo mkdir edh_modules
        test -w edh-universe || edo mkdir edh-universe
       ) || die "Can NOT create local directories in $(pwd)"

       # check for available commands
       missing_commands="$(check_required_commands )"
       if [ -n "${missing_commands}" ] ; then
           die "Following commands are required, but missing, please install: ${missing_commands}"
       fi
       unset missing_commands

       case $1 in
       install|i)
           shift 1
           PKGS2INST=""
           while [ $# -gt 0 ] ; do
               case $1 in
                   -h|--help) install_usage;;
                   -f|--force) FORCE=true
                      shift 1;;
                   -b|--base)
                        if [ $# -lt 2 ] ; then
                            install_usage
                        fi
                        BASE_URL="$2"
                        shift 2;;
                   *) PKGS2INST="${PKGS2INST} $1"
                      shift 1;;
               esac
           done
           install_pkgs ${PKGS2INST}
           break;;
       list|l)
           shift 1
           while [ $# -gt 0 ] ; do
               case $1 in
                   -h|--help) list_usage;;
                   -u|--upstream) SHOW_REPO=true
                       shift 1;;
                   -b|--branch) SHOW_BRANCH=true
                       shift 1;;
                   -m|--modules) SHOW_MODULES=true
                       shift 1;;
                   *) list_usage;;
               esac
           done
           list_pkgs
           break;;
       update|u)
           update_pkgs
           break;;
       rm)
           shift 1
           PKGS2RM=""
           while [ $# -gt 0 ] ; do
               case $1 in
                   -h|--help) rm_usage;;
                   -f|--force) FORCE=true
                      shift 1;;
                   *) PKGS2RM="${PKGS2RM} $1"
                      shift 1;;
               esac
           done
           rm_pkgs ${PKGS2RM}
           break;;
       *) usage;;
       esac
       break;;
    esac
done


)
